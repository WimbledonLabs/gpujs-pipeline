<html>
    <head>

<style>
body {

}

#debug {
    font-family: monospace;
    color: #f0f0f0;
    background-color: #333333;
    word-break: break-all;
    padding: 0.2em;
}
</style>
    </head>
    <body onload="test()">
    <div id="debug"></div>

    <canvas id="scaled" width="512" height="512">
    </canvas>

    <script src="js/gpu.js?nocache"></script>
    <script>
function print(s) {
    document.getElementById("debug").innerHTML += s + "<br />";
}

// sleep taken from http://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep
function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
}

var mode = "gpu";

var gpu = new GPU();
var opt = {
        dimensions: [100]
};

var myFunc = gpu.createKernel(function(x) {
    return this.dimensions.z;
}).mode(mode).dimensions([100]);

var render = gpu.createKernel(function() {
    var sx = (this.thread.x - 10) / 8;
    var sy = (this.thread.y - 10) / 8;
    var c = Math.sqrt(sx*sx + sy*sy);
    this.color(c, c, c, 1);
}).mode(mode).dimensions([20, 20]).width(512).height(512).graphical(true);


var step = gpu.createKernel(function(grid) {
    return 1;
    var x = this.thread.x;
    var y = this.thread.y;

    if (x < 0.5 || y < 0.5 || y > this.dimensions.y - 1.5 || x > this.dimensions.x - 1.5) {
        return 0;
    }

    var s = grid[y-1][x-1] + grid[y-1][x+0] + grid[y-1][x+1] +
            grid[y-0][x-1] +       0        + grid[y-0][x+1] +
            grid[y+1][x-1] + grid[y+1][x+0] + grid[y+1][x+1];

    var ts = 2*(s - 2.5 - 0.5*(1-grid[y][x]));
    var dts = 1.5*ts + 0.1;

    //return Math.round(Math.min(1, Math.abs(1/dts)));

    /*

    if (grid[y][x] < 0.5 && s > 2.5 && s < 3.5) {
        return 1;
    } else if (grid[y][x] > 0.5 && s > 1.5 && s < 3.5) {
        return 1;
    } else {
        return 0;
    }

    return 1; // There should be no reason to get here...
    // */
}).mode(mode).dimensions([50, 50]).width(512).height(512);//.graphical(true);

var show = gpu.createKernel(function(grid) {
    var c = grid[this.thread.y][this.thread.x];
    this.color(c,0,1,1);
    //this.color(c, c, c, 1);
}).mode(mode).dimensions([50, 50]).width(512).height(512).graphical(true);

var canvas = show.getCanvas();
document.getElementsByTagName('body')[0].appendChild(canvas);

var scaledNode = document.getElementById("scaled");
var scaled = scaledNode.getContext('2d');
scaled.imageSmoothingEnabled = false;
scaled.mozImageSmoothingEnabled = false;
scaled.webkitImageSmoothingEnabled = false;
scaled.msImageSmoothingEnabled = false;

var xsize = 50;
var ysize = 50;

var r = [];

for (var y=0; y<ysize; y++) {
    //var row = [];
    //for (var x=0; x<xsize; x++) {
    //    row.push(0);
    //}
    //r.push(row);
    r.push(new Float32Array(xsize));
}

r[0][0] = 1;
r[1][1] = 1;
r[49][49] = 1;
r[48][48] = 1;
r[0][49] = 1;
r[1][48] = 1;
r[49][0] = 1;
r[48][1] = 1;

r[24][25] = 1;
r[25][25] = 1;
r[25][26] = 1;
r[25][24] = 1;
r[26][24] = 1;


if (mode !== "cpu") {
    scaledNode.style.display = "none";
}

print("in");
print(r);
print("out");
print(step(r));

var i = 0;
var X = r;
async function test() {
    while (1) {
        var t = 0;
        for (iter=0; iter<i; iter++) {
            X = step(X);
        }
        show(r);
        await sleep(t);
        if (mode === "cpu") {
            scaled.drawImage(canvas, 0, 0, xsize, ysize,
                                     0, 0, 512, 512);
        }
        await sleep(700 - t);
        i += 1;
    }
}

//test()

    </script>
    </body>
</html>
