<html>
    <head>

<style>
body {

}

#debug {
    font-family: monospace;
    color: #f0f0f0;
    background-color: #333333;
    word-break: break-all;
    padding: 0.2em;
    height: 30%;

    overflow-y: scroll;
}
</style>
    </head>
    <body onload="test()">
    <div id="debug"></div>

    <canvas id="scaled" width="512" height="512">
    </canvas>

    <script src="js/gpu.js?nocache"></script>
    <script>
function print(s) {
    var debugDiv = document.getElementById("debug");
    debugDiv.innerHTML += s + "<br />";
    debugDiv.scrollTop = debugDiv.scrollHeight - debugDiv.clientHeight;

}

// sleep taken from http://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep
function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
}

var mode = "gpu";

// Input dimensions
var xsize = 1024;
var ysize = 1024;

// Output Dimensions
var canvas_width = 1024;
var canvas_height = 1024;

var gpu = new GPU();
var opt = {
        dimensions: [100]
};

/*
var myFunc = gpu.createKernel(function(x) {
    return this.dimensions.z;
}).mode(mode).dimensions([100]);

var render = gpu.createKernel(function() {
    var sx = (this.thread.x - 10) / 8;
    var sy = (this.thread.y - 10) / 8;
    var c = Math.sqrt(sx*sx + sy*sy);
    this.color(c, c, c, 1);
}).mode(mode).dimensions([20, 20]).width(512).height(512).graphical(true);
*/


var step = gpu.createKernel(function(grid) {
    //return Math.max(1, grid[this.thread.y][this.thread.x]);

    if (this.thread.x < 0.5 || this.thread.x > this.dimensions.x - 1.5 ||
        this.thread.y < 0.5 || this.thread.y > this.dimensions.y - 1.5    ) {
        return 0;
    }

    var a = grid[this.thread.y-1][this.thread.x-1] +
                    grid[this.thread.y-1][this.thread.x+0] +
                            grid[this.thread.y-1][this.thread.x+1];
    var b = grid[this.thread.y-0][this.thread.x-1] + 
                    0 +
                            grid[this.thread.y-0][this.thread.x+1];
    var c = grid[this.thread.y+1][this.thread.x-1] +
                    grid[this.thread.y+1][this.thread.x+0] +
                            grid[this.thread.y+1][this.thread.x+1];

    var s = a + b + c;

    var ts = 2*(s - 2.5 - 0.5*(1-grid[this.thread.y][this.thread.x]));
    var dts = 1.5*ts + 0.1;

    return Math.floor(0.5 + Math.min(1, Math.abs(1/dts)));

    /*

    if (grid[this.thread.y][x] < 0.5 && s > 2.5 && s < 3.5) {
        return 1;
    } else if (grid[this.thread.y][x] > 0.5 && s > 1.5 && s < 3.5) {
        return 1;
    } else {
        return 0;
    }

    return 1; // There should be no reason to get here...
    // */
}).mode(mode)
.dimensions([xsize, ysize])
    .floatOutput(false)
    .floatTextures(false)
    .debug(true)
    .outputToTexture(true);//.graphical(true);

var show = gpu.createKernel(function(grid) {
    var c = grid[this.thread.y][this.thread.x];
    this.color(c,0,1,1);
    //this.color(c, c, c, 1);
}).mode(mode).dimensions([xsize, ysize]).width(canvas_width).height(canvas_height).graphical(true);

var canvas = show.getCanvas();

if (mode !== "cpu") {
    document.getElementsByTagName('body')[0].appendChild(canvas);
}

var scaledNode = document.getElementById("scaled");
var scaled = scaledNode.getContext('2d');
scaled.imageSmoothingEnabled = false;
scaled.mozImageSmoothingEnabled = false;
scaled.webkitImageSmoothingEnabled = false;
scaled.msImageSmoothingEnabled = false;

scaledNode.width = canvas_width;
scaledNode.height = canvas_height;

var r = [];

for (var y=0; y<ysize; y++) {
    row = new Array(xsize);
    row.fill(0);
    r.push(row);
    //var row = [];
    //for (var x=0; x<xsize; x++) {
    //    row.push(0);
    //}
    //r.push(row);
    //r.push(new Float32Array(xsize));
}

r[524][525] = 1;
r[525][525] = 1;
r[525][526] = 1;
r[525][524] = 1;
r[526][524] = 1;


if (mode !== "cpu") {
    scaledNode.style.display = "none";
}

//print("in");
//print(r);
//print("out");
//print(step(r));

var i = 0;
var X = r;
var Y;

async function test() {
    while (1) {
        var t = 0;
        var sleepFor = 10;
        //for (iter=0; iter<i; iter++) {
            X = step(X);
        //}
        Y = step(X);
        show(Y);
        X = step(Y);
        show(X);

        await sleep(t);
        if (mode === "cpu") {
            scaled.drawImage(canvas, 0, 0, xsize, ysize,
                                     0, 0, canvas_width, canvas_height);
        }
        await sleep(sleepFor - t);
        i += 1;
    }
}

//test()

    </script>
    </body>
</html>
